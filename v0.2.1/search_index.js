var documenterSearchIndex = {"docs":
[{"location":"api/ksp/#PETSc-KSP","page":"PETSc KSP","title":"PETSc KSP","text":"","category":"section"},{"location":"api/ksp/","page":"PETSc KSP","title":"PETSc KSP","text":"Modules = [PetscWrap]\nPages   = [\"src/ksp.jl\"]","category":"page"},{"location":"example/linear_system_fancy/#A-first-demo-with-fancy-names","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"","category":"section"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"This example does more or less the same things as the first example, but using non regular API function names.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"This example serves as a test since this project doesn't have a \"testing\" procedure yet. In this example, the equation u(x) = 2 with u(0) = 0 is solved on the domain 01 using a backward finite difference scheme.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Note that the way we achieve things in the document can be highly improved and the purpose of this example is only demonstrate some method calls to give an overview.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"To run this example, execute : mpirun -n your_favorite_positive_integer julia example2.jl","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Import package","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"using PetscWrap","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Initialize PETSc. Command line arguments passed to Julia are parsed by PETSc. Alternatively, you can also provide \"command line arguments by defining them in a string, for instance PetscInitialize(\"-ksp_monitor_short -ksp_gmres_cgs_refinement_type refine_always\") or by providing each argument in separate strings : PetscInitialize([\"-ksp_monitor_short\", \"-ksp_gmres_cgs_refinement_type\", \"refine_always\")","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"PetscInitialize()","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Number of mesh points and mesh step","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"n = 11\nΔx = 1.0 / (n - 1)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Create a matrix of size (n,n) and a vector of size (n). The autosetup option triggers a call to setFromOptions and setUp","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"A = create_matrix(; nrows_glo = n, ncols_glo = n, autosetup = true)\nb = create_vector(; nrows_glo = n, autosetup = true)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Let's build the right hand side vector. We first get the range of rows of b handled by the local processor. The rstart, rend = get_range(*) methods differ a little bit from PETSc API since the two integers it returns are the effective Julia range of rows handled by the local processor. If n is the total number of rows, then rstart ∈ [1,n] and rend is the last row handled by the local processor.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"b_start, b_end = get_range(b)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Now let's build the right hand side vector. Their are various ways to do this, this is just one.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"n_loc = length(b) ## Note that n_loc = b_end - b_start + 1...\nb[b_start:b_end] = 2 * ones(n_loc)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"And here is the differentiation matrix. Rembember that PETSc.MatSetValues simply ignores negatives rows indices.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"A_start, A_end = get_range(A)\nfor i = A_start:A_end\n    A[i, (i - 1):i] = [-1.0 1.0] / Δx\nend","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Set boundary condition (only the proc handling index 1 is acting)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"(b_start == 1) && (b[1] = 0.0)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Assemble matrice and vector","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"assemble!(A)\nassemble!(b)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Set up the linear solver","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"ksp = create_ksp(A; autosetup = true)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Solve the system","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"x = solve(ksp, b)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Print the solution (here x is still a PetscVec)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"@show x","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Convert PetscVec to Julia Array (and play with it!)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"array = vec2array(x)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Free memory (optional, objects are garbage collected otherwise)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"destroy!(A, b, x, ksp)","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"Note that it's also possible to build a matrix using the COO format as in SparseArrays:","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"M = create_matrix(; nrows_glo = 3, ncols_glo = 3, autosetup = true)\nM_start, M_end = get_range(M)\nI = [1, 1, 1, 2, 3]\nJ = [1, 3, 1, 3, 2]\nV = [1, 2, 3, 4, 5]\nk = findall(x -> M_start <= x <= M_end, I) # just a trick to allow this example to run in parallel\nset_values!(M, I[k], J[k], V[k], ADD_VALUES)\nassemble!(M)\n@show M","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"This is very convenient in sequential since you can fill the three vectors I, J, V in your code and decide only at the last moment if you'd like to use SparseArrays or PetscMat.","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"destroy!(M)\n","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"","category":"page"},{"location":"example/linear_system_fancy/","page":"A first demo with fancy names","title":"A first demo with fancy names","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/vec/#PETSc-Vec","page":"PETSc Vec","title":"PETSc Vec","text":"","category":"section"},{"location":"api/vec/","page":"PETSc Vec","title":"PETSc Vec","text":"Modules = [PetscWrap]\nPages   = [\"src/vec.jl\"]","category":"page"},{"location":"api/mat/#PETSc-Mat","page":"PETSc Mat","title":"PETSc Mat","text":"","category":"section"},{"location":"api/mat/","page":"PETSc Mat","title":"PETSc Mat","text":"Modules = [PetscWrap]\nPages   = [\"src/mat.jl\"]","category":"page"},{"location":"example/linear_system/#A-first-demo","page":"A first demo","title":"A first demo","text":"","category":"section"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"This example serves as a test since this project doesn't have a \"testing\" procedure yet. In this example, the equation u(x) = 2 with u(0) = 0 is solved on the domain 01 using a backward finite difference scheme.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"In this example, PETSc classic method names are used. For more fancy names, check the fancy version.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Note that the way we achieve things in the document can be highly improved and the purpose of this example is only demonstrate some method calls to give an overview.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"To run this example, execute : mpirun -n your_favorite_positive_integer julia example1.jl","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Import package","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"using PetscWrap","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Initialize PETSc. Command line arguments passed to Julia are parsed by PETSc. Alternatively, you can also provide \"command line arguments by defining them in a string, for instance PetscInitialize(\"-ksp_monitor_short -ksp_gmres_cgs_refinement_type refine_always\") or by providing each argument in separate strings : PetscInitialize([\"-ksp_monitor_short\", \"-ksp_gmres_cgs_refinement_type\", \"refine_always\")","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"PetscInitialize()","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Number of mesh points and mesh step","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"n = 11\nΔx = 1.0 / (n - 1)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Create a matrix and a vector (you can specify the MPI communicator if you want)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"A = create(Mat)\nb = create(Vec)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Set the size of the different objects, leaving PETSC to decide how to distribute. Note that we should set the number of preallocated non-zeros to increase performance.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"setSizes(A, PETSC_DECIDE, PETSC_DECIDE, n, n)\nsetSizes(b, PETSC_DECIDE, n)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"We can then use command-line options to set our matrix/vectors.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"setFromOptions(A)\nsetFromOptions(b)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Finish the set up","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"setUp(A)\nsetUp(b)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Let's build the right hand side vector. We first get the range of rows of b handled by the local processor. As in PETSc, the rstart, rend = *GetOwnershipRange methods indicate the first row handled by the local processor (starting at 0), and the last row (which is rend-1). This may be disturbing for non-regular PETSc users. Checkout the fancy version of this example for a more Julia-like convention.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"b_start, b_end = getOwnershipRange(b)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Now let's build the right hand side vector. Their are various ways to do this, this is just one.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"n_loc = getLocalSize(b) # Note that n_loc = b_end - b_start...\nsetValues(b, collect(b_start:(b_end - 1)), 2 * ones(n_loc))","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"And here is the differentiation matrix. Rembember that PETSc.MatSetValues simply ignores negatives rows indices.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"A_start, A_end = getOwnershipRange(A)\nfor i = A_start:(A_end - 1)\n    setValues(A, [i], [i - 1, i], [-1.0 1.0] / Δx, INSERT_VALUES) # setValues(A, I, J, V, INSERT_VALUES)\nend","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Set boundary condition (only the proc handling index 0 is acting)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"(b_start == 0) && setValue(b, 0, 0.0)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Assemble matrices","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"assemblyBegin(A, MAT_FINAL_ASSEMBLY)\nassemblyBegin(b)\nassemblyEnd(A, MAT_FINAL_ASSEMBLY)\nassemblyEnd(b)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"At this point, you can inspect A or b using a viewer (stdout by default), simply call","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"matView(A)\nvecView(b)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Set up the linear solver","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"ksp = create(KSP)\nsetOperators(ksp, A, A)\nsetFromOptions(ksp)\nsetUp(ksp)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Solve the system. We first allocate the solution using the VecDuplicate method.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"x = duplicate(b)\nsolve(ksp, b, x)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Print the solution","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"vecView(x)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Access the solution (this part is under development), getting a Julia array; and then restore it","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"array, ref = getArray(x) # do something with array\n@show array\nrestoreArray(x, ref)","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Free memory. Note that this call is faculative since, by default, the julia GC will trigger a call to Petsc destroy to each object","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"destroy.((ksp, A, b, x))","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"Finalize Petsc. This call is faculative : it will be triggered automatically at the end of the script.","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"PetscFinalize()\n","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"","category":"page"},{"location":"example/linear_system/","page":"A first demo","title":"A first demo","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/init/#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"api/init/","page":"Initialization","title":"Initialization","text":"Modules = [PetscWrap]\nPages   = [\"init.jl\"]","category":"page"},{"location":"api/init/#PetscWrap.PetscFinalize-Tuple{}","page":"Initialization","title":"PetscWrap.PetscFinalize","text":"Wrapper to PetscFinalize\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscFinalized-Tuple{}","page":"Initialization","title":"PetscWrap.PetscFinalized","text":"Wrapper to PetscFinalized\n\nCmd line options: -optionsview - Calls PetscOptionsView() -optionsleft - Prints unused options that remain in the database -objectsdump [all] - Prints list of objects allocated by the user that have not been freed, the option all cause all outstanding objects to be listed -mpidump - Calls PetscMPIDump() -mallocdump - Calls PetscMallocDump(), displays all memory allocated that has not been freed -mallocinfo - Prints total memory usage -mallocview - Prints list of all memory allocated and where\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscInitialize","page":"Initialization","title":"PetscWrap.PetscInitialize","text":"PetscInitialize(cmd_line_args::Bool = true; finalize_atexit = true)\n\nInitialize PETSc.\n\nIf cmd_line_args == true, then command line arguments passed to Julia are used as arguments for PETSc (leading to a call to PetscInitializeNoPointers).\n\nOtherwise, if cmd_line_args == false, initialize PETSc without arguments (leading to a call to PetscInitializeNoArguments).\n\n\n\n\n\n","category":"function"},{"location":"api/init/#PetscWrap.PetscInitialize-Tuple{String}","page":"Initialization","title":"PetscWrap.PetscInitialize","text":"Initialize PETSc with arguments concatenated in a unique string.\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscInitialize-Tuple{Vector{String}, String, String}","page":"Initialization","title":"PetscWrap.PetscInitialize","text":"Wrapper to `PetscInitializeNoPointers`. Initialize PETCs with arguments.\n\nImplementation\n\nI don't know if I am supposed to use PetscInt or not...\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscInitialize-Tuple{Vector{String}}","page":"Initialization","title":"PetscWrap.PetscInitialize","text":"Initialize PETSc with arguments stored in a vector of string\n\n\n\n\n\n","category":"method"},{"location":"api/init/#PetscWrap.PetscInitialized-Tuple{}","page":"Initialization","title":"PetscWrap.PetscInitialized","text":"Wrapper to PetscInitialized\n\n\n\n\n\n","category":"method"},{"location":"api/viewer/#PETSc-Viewer","page":"PETSc Viewer","title":"PETSc Viewer","text":"","category":"section"},{"location":"api/viewer/","page":"PETSc Viewer","title":"PETSc Viewer","text":"Modules = [PetscWrap]\nPages   = [\"viewer.jl\"]","category":"page"},{"location":"api/viewer/#PetscWrap.PetscViewer","page":"PETSc Viewer","title":"PetscWrap.PetscViewer","text":"PetscViewer(\n    comm::MPI.Comm,\n    filename::String,\n    format::PetscViewerFormat = PETSC_VIEWER_ASCII_CSV,\n    type::String = \"ascii\",\n    mode::PetscFileMode = FILE_MODE_WRITE,\n)\n\nConstructor for a PetscViewer intended to read/write a matrix or a vector with the supplied type and format.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PetscWrap","category":"page"},{"location":"#PetscWrap.jl","page":"Home","title":"PetscWrap.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the examples or the API.","category":"page"},{"location":"api/fancy/fancy/#PETSc-Vec","page":"API fancy","title":"PETSc Vec","text":"","category":"section"},{"location":"api/fancy/fancy/","page":"API fancy","title":"API fancy","text":"Modules = [PetscWrap]\nPages   = [\"fancy/vec.jl\"]","category":"page"},{"location":"api/fancy/fancy/#Base.setindex!-Tuple{Vec, Number, Integer}","page":"API fancy","title":"Base.setindex!","text":"Base.setindex!(vec::Vec, value::Number, row::Integer)\n\nrow must be in [1,size(vec)], i.e indexing starts at 1 (Julia).\n\nImplementation\n\nFor some unkwnown reason, calling VecSetValue fails.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.create_vector","page":"API fancy","title":"PetscWrap.create_vector","text":"create_vector(\n    comm::MPI.Comm = MPI.COMM_WORLD;\n    nrows_loc = PETSC_DECIDE,\n    nrows_glo = PETSC_DECIDE,\n    autosetup = false,\n)\n\nCreate a Vec vector of global size (nrows_glo).\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.get_range-Tuple{Vec}","page":"API fancy","title":"PetscWrap.get_range","text":"get_range(vec::Vec)\n\nWrapper to VecGetOwnershipRange\n\nHowever, the result (rstart, rend) is such that vec[rstart:rend] are the rows handled by the local processor. This is different from the default PETSc.VecGetOwnershipRange result where the indexing starts at zero and where rend-1 is last row handled by the local processor.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.get_urange-Tuple{Vec}","page":"API fancy","title":"PetscWrap.get_urange","text":"get_urange(vec::Vec)\n\nProvide a UnitRange from the method get_range.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.get_values!-Tuple{AbstractVector{Float64}, Vec}","page":"API fancy","title":"PetscWrap.get_values!","text":"In construction\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.set_local_to_global!-Union{Tuple{I}, Tuple{Vec, Vector{I}}} where I<:Integer","page":"API fancy","title":"PetscWrap.set_local_to_global!","text":"Wrapper to ISSetLocalToGlobalMapping\n\n1-based indexing\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.set_value!","page":"API fancy","title":"PetscWrap.set_value!","text":"set_value!(vec::Vec, row, value, mode::InsertMode = INSERT_VALUES)\n\nWrapper to VecSetValue, using julia 1-based indexing.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.set_value_local!","page":"API fancy","title":"PetscWrap.set_value_local!","text":"set_value_local!(vec::Vec, row, value, mode::InsertMode = INSERT_VALUES)\n\nWrapper to VecSetValueLocal, using julia 1-based indexing.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.set_values!","page":"API fancy","title":"PetscWrap.set_values!","text":"set_values!(vec::Vec, rows, values, mode::InsertMode = INSERT_VALUES)\nset_values!(vec::Vec, values)\n\nWrapper to VecSetValues, using julia 1-based indexing.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.set_values_local!","page":"API fancy","title":"PetscWrap.set_values_local!","text":"set_values_local!(vec::Vec, rows, values, mode::InsertMode = INSERT_VALUES)\nset_values_local!(vec::Vec, values)\n\nWrapper to VecSetValuesLocal, using julia 1-based indexing.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.vec2array-Tuple{Vec}","page":"API fancy","title":"PetscWrap.vec2array","text":"vec2array(vec::Vec)\n\nConvert a Vec into a Julia Array. Allocation is involved in the process since the Vec allocated by PETSC is copied into a freshly allocated array. If you prefer not to allocate memory, use VectGetArray and VecRestoreArray\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.vec2file","page":"API fancy","title":"PetscWrap.vec2file","text":"vec2file(vec::Vec, filename::String, format::PetscViewerFormat = PETSC_VIEWER_ASCII_CSV, type::String = \"ascii\")\n\nWrite a Vec to a file.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PETSc-Mat","page":"API fancy","title":"PETSc Mat","text":"","category":"section"},{"location":"api/fancy/fancy/","page":"API fancy","title":"API fancy","text":"Modules = [PetscWrap]\nPages   = [\"fancy/mat.jl\"]","category":"page"},{"location":"api/fancy/fancy/#Base.setindex!-Tuple{Mat, Number, Integer, Integer}","page":"API fancy","title":"Base.setindex!","text":"row and col must be in [1,size(mat)], i.e indexing starts at 1 (Julia).\n\nImplementation\n\nFor some unkwnown reason, calling MatSetValue fails.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.assemble!","page":"API fancy","title":"PetscWrap.assemble!","text":"Wrapper to `MatAssemblyBegin` and `MatAssemblyEnd` successively.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.create_composite_add-Tuple{Any}","page":"API fancy","title":"PetscWrap.create_composite_add","text":"Wrapper to MatCreateComposite using the \"alternative construction\" from the PETSc documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.create_matrix","page":"API fancy","title":"PetscWrap.create_matrix","text":"create_matrix(\n    comm::MPI.Comm = MPI.COMM_WORLD;\n    nrows_loc = PETSC_DECIDE,\n    ncols_loc = PETSC_DECIDE,\n    nrows_glo = PETSC_DECIDE,\n    ncols_glo = PETSC_DECIDE,\n    autosetup = false,\n)\n\nUse autosetup = true to immediatly call set_from_options! and set_up!.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.get_range-Tuple{Mat}","page":"API fancy","title":"PetscWrap.get_range","text":"get_range(mat::Mat)\n\nWrapper to MatGetOwnershipRange\n\nHowever, the result (rstart, rend) is such that mat[rstart:rend] are the rows handled by the local processor. This is different from the default PETSc.MatGetOwnershipRange result where the indexing starts at zero and where rend-1 is last row handled by the local processor.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.get_urange-Tuple{Mat}","page":"API fancy","title":"PetscWrap.get_urange","text":"get_urange(mat::Mat)\n\nProvide a UnitRange from the method get_range.\n\n\n\n\n\n","category":"method"},{"location":"api/fancy/fancy/#PetscWrap.mat2file","page":"API fancy","title":"PetscWrap.mat2file","text":"mat2file(mat::Mat, filename::String, format::PetscViewerFormat = PETSC_VIEWER_ASCII_CSV, type::String = \"ascii\")\n\nWrite a Mat to a file.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.preallocate!","page":"API fancy","title":"PetscWrap.preallocate!","text":"preallocate!(mat::Mat, dnz, onz, warn::Bool = true)\n\nDispatch preallocation according matrix type (seq or mpiaij for instance). TODO: should use kwargs.\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.set_value!-2","page":"API fancy","title":"PetscWrap.set_value!","text":"set_value!(mat::Mat, I, J, V, mode = ADD_VALUES)\n\nSet value of mat mat[i, j] = v.\n\n1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PetscWrap.set_values!-2","page":"API fancy","title":"PetscWrap.set_values!","text":"set_values!(mat::Mat, I, J, V, mode = ADD_VALUES)\n\nSet values of mat in SparseArrays fashion : using COO format: mat[I[k], J[k]] = V[k].\n\n\n\n\n\n","category":"function"},{"location":"api/fancy/fancy/#PETSc-KSP","page":"API fancy","title":"PETSc KSP","text":"","category":"section"},{"location":"api/fancy/fancy/","page":"API fancy","title":"API fancy","text":"Modules = [PetscWrap]\nPages   = [\"fancy/ksp.jl\"]","category":"page"}]
}
